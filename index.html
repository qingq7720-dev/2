<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿äº¤äº’ç²’å­å®‡å®™</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        
        /* éšè—è§†é¢‘è¾“å…¥å…ƒç´ ï¼Œæˆ‘ä»¬åªéœ€è¦æ•°æ® */
        .input_video { display: none; }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        .glass-panel {
            background: rgba(20, 20, 35, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 50px; height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- åŠ è½½é®ç½© -->
    <div id="loading" class="loading-overlay">
        <div class="spinner mb-4"></div>
        <div class="text-white text-lg font-light tracking-widest">åˆå§‹åŒ–è§†è§‰ç³»ç»Ÿ...</div>
        <div class="text-gray-500 text-sm mt-2">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</div>
    </div>

    <!-- ç”¨äºMediaPipeçš„è§†é¢‘è¾“å…¥ -->
    <video class="input_video"></video>

    <!-- UI æ§åˆ¶é¢æ¿ -->
    <div class="fixed top-6 left-6 w-72 glass-panel rounded-2xl p-6 text-white z-50 transition-all duration-300 hover:bg-opacity-90">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-xl font-bold tracking-wider bg-clip-text text-transparent bg-gradient-to-r from-red-400 to-pink-500">
                ç²’å­æ§åˆ¶å™¨
            </h1>
            <!-- æ‰‹åŠ¿è¿½è¸ªçŠ¶æ€ç¯ -->
            <div id="hand-status" class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_rgba(239,68,68,0.6)]" title="æ‰‹åŠ¿è¿½è¸ªçŠ¶æ€"></div>
        </div>

        <div class="space-y-5">
            <!-- æ¨¡å¼é€‰æ‹© -->
            <div>
                <label class="text-xs text-gray-400 uppercase tracking-widest mb-2 block">æ¨¡å‹é¢„è®¾</label>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="switchMode('starfield')" class="mode-btn py-2 px-4 rounded-lg bg-white/10 hover:bg-red-500/20 hover:text-red-300 transition text-sm font-medium border border-white/5 focus:outline-none focus:ring-2 focus:ring-red-500 active-mode" id="btn-starfield">
                        â¤ï¸ æ˜Ÿäº‘ä¹‹å¿ƒ
                    </button>
                    <button onclick="switchMode('saturn')" class="mode-btn py-2 px-4 rounded-lg bg-white/10 hover:bg-purple-500/20 hover:text-purple-300 transition text-sm font-medium border border-white/5 focus:outline-none focus:ring-2 focus:ring-purple-500" id="btn-saturn">
                        ğŸ’– åœŸæ˜Ÿä¹‹æ‹
                    </button>
                </div>
            </div>

            <!-- é¢œè‰²æ§åˆ¶ -->
            <div>
                <label class="text-xs text-gray-400 uppercase tracking-widest mb-2 block">ç²’å­æ ¸å¿ƒè‰²</label>
                <div class="flex items-center space-x-3 bg-white/5 p-2 rounded-lg">
                    <input type="color" id="colorPicker" value="#ff0000" class="w-8 h-8 rounded cursor-pointer border-none bg-transparent">
                    <span class="text-sm font-mono text-gray-300" id="colorValue">#FF0000</span>
                </div>
            </div>

            <!-- è¯´æ˜ -->
            <div class="pt-4 border-t border-white/10">
                <div class="flex items-start space-x-3 text-sm text-gray-400">
                    <span class="text-lg">ğŸ‘‹</span>
                    <p class="leading-relaxed">
                        åœ¨æ‘„åƒå¤´å‰ä¸¾èµ·ä¸€åªæˆ–ä¸¤åªæ‰‹ã€‚<br>
                        <span class="text-white">æåˆæ‰‹æŒ‡</span> = èšåˆæ¨¡å‹<br>
                        <span class="text-white">å¼ å¼€äº”æŒ‡</span> = ç²’å­çˆ†ç‚¸<br>
                        <span class="text-white">å·¦å³ç§»åŠ¨æ‰‹</span> = æ—‹è½¬æ¨¡å‹<br>
                        <span class="text-pink-300">å®Œå…¨å¼ å¼€æ‰‹æŒ‡ 2 ç§’</span> = å‡ºç° I LOVE YOU<br>
                        <span class="text-pink-300">åŒæ‰‹åŒæ—¶æåˆ</span> = é€€å‡º I LOVE YOU æ¨¡å¼
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- å…¨å±æŒ‰é’® (å¢å¼ºç‰ˆ) -->
    <button id="fullscreen-btn" onclick="toggleFullScreen()" class="fixed bottom-6 right-6 p-4 glass-panel rounded-full text-white hover:bg-white/20 hover:scale-105 transition-all duration-200 z-50 group shadow-lg" title="åˆ‡æ¢å…¨å±">
        <!-- æ­£å¸¸å…¨å±å›¾æ ‡ -->
        <svg id="icon-enter" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 group-hover:text-red-300 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
        </svg>
        <!-- é€€å‡ºå…¨å±å›¾æ ‡ (é»˜è®¤éšè—) -->
        <svg id="icon-exit" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden group-hover:text-red-300 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14H6m0 0v4m0-4l5 5m8-5h4m-4 0v4m0-4l-5 5M14 10h4m0 0V6m0 0l-5 5M10 10H6m0 0V6m0 0l5 5" />
        </svg>
    </button>

    <!-- äº¤äº’æç¤ºåé¦ˆ -->
    <div id="gesture-feedback" class="fixed bottom-10 left-1/2 transform -translate-x-1/2 text-white/50 text-sm font-mono tracking-widest pointer-events-none transition-opacity duration-300 opacity-0">
        æ‰©æ•£ç³»æ•°: <span id="diffusion-val">0%</span>
    </div>
    
    <!-- æ–‡å­—æ¨¡å¼å€’è®¡æ—¶åé¦ˆ (æ–°å¢) -->
    <div id="text-countdown" class="fixed bottom-24 left-1/2 transform -translate-x-1/2 text-pink-400 text-xl font-bold tracking-widest pointer-events-none transition-opacity duration-300 opacity-0">
        æ­£åœ¨è®¡æ—¶...
    </div>


    <script>
        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            particleCount: 6000,
            baseColor: 0xff0000, // é»˜è®¤æ”¹ä¸ºçº¢è‰²
            particleSize: 0.3, // å¢åŠ å°ºå¯¸è®©å¿ƒå½¢æ›´æ¸…æ™°
            lerpSpeed: 0.08, // æ¨¡å‹å˜æ¢é€Ÿåº¦
            handSensitivity: 2.0, // æ‰‹åŠ¿æ•æ„Ÿåº¦
            textDelayDuration: 2000, // 2ç§’
            maxExpansionThreshold: 0.95, // è§¦å‘ I LOVE YOU çš„æœ€å°æ‰©å¼ ç¨‹åº¦
            exitTextThreshold: 0.1, // é€€å‡º I LOVE YOU æ¨¡å¼çš„æœ€å¤§æ‰©å¼ ç¨‹åº¦ (ç°åœ¨éœ€è¦éå¸¸å°ï¼Œè¡¨ç¤ºæåˆ)
        };
        const BACKGROUND_STAR_COUNT = 5000; // èƒŒæ™¯æ˜Ÿç©ºç²’å­æ•°é‡

        // --- Three.js å˜é‡ ---
        let scene, camera, renderer, particles, geometry;
        let material;
        let backgroundStars; 
        let animationId;
        
        // ç²’å­ç›®æ ‡ä½ç½®å­˜å‚¨
        const positionsStarfield = new Float32Array(CONFIG.particleCount * 3);
        const positionsSaturn = new Float32Array(CONFIG.particleCount * 3);
        const positionsILoveYou = new Float32Array(CONFIG.particleCount * 3); 
        
        // çŠ¶æ€
        let targetMode = 'starfield'; 
        let originalMode = 'starfield'; // å­˜å‚¨è¿›å…¥æ–‡å­—æ¨¡å¼å‰çš„æ¨¡å¼ (æ–°å¢)
        let handExpansionFactor = 0; // 0 = æ­£å¸¸, 1 = æœ€å¤§æ‰©æ•£
        let smoothedExpansion = 0;   // ç”¨äºå¹³æ»‘åŠ¨ç”»

        // --- æ‰‹åŠ¿äº¤äº’æ—‹è½¬å˜é‡ ---
        let lastHandX = null;        
        let targetRotationY = 0;     
        let rotationVelocity = 0;    
        
        // --- I LOVE YOU æ¨¡å¼çŠ¶æ€ ---
        let isMaxExpansion = false;
        let maxExpansionStartTime = 0;
        let isILoveYouMode = false;


        // --- 1. Three.js åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 10;
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // ç”Ÿæˆå¿ƒå½¢ç²’å­çº¹ç† (å‘å…‰ç‚¹)
            const heartSprite = getHeartTexture();

            // ç”Ÿæˆå‡ ä½•æ•°æ®
            generateStarfieldData();
            generateSaturnData();
            generateILoveYouData(); // æ–°å¢ï¼šç”Ÿæˆ I LOVE YOU æ–‡å­—æ•°æ®

            // åˆå§‹å‡ ä½•ä½“
            geometry = new THREE.BufferGeometry();
            // æ·±åº¦å…‹éš†ä¸€ä»½æ•°æ®ä½œä¸ºèµ·å§‹ç‚¹
            geometry.setAttribute('position', new THREE.BufferAttribute(positionsStarfield.slice(), 3));
            
            // é¢œè‰²å±æ€§
            const colors = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<colors.length; i++) colors[i] = 1.0;
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // æè´¨
            material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                map: heartSprite, 
                color: CONFIG.baseColor,
                transparent: true,
                opacity: 0.9, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            initBackgroundStars();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // --- 2. å‡ ä½•æ•°æ®ç”Ÿæˆå™¨ä¸çº¹ç† ---

        // è¾…åŠ©ï¼šç”Ÿæˆå¿ƒå½¢çº¹ç†
        function getHeartTexture() {
            const size = 64; 
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            const center = size / 2;
            const scaleFactor = 30; 

            context.fillStyle = 'white';

            context.save();
            context.translate(center, center - scaleFactor * 0.1); 
            context.scale(scaleFactor, -scaleFactor); 

            context.beginPath();
            context.moveTo(0, -1.0); 
            context.bezierCurveTo(-1.0, 0.0, -0.5, 1.2, 0.0, 0.5); 
            context.bezierCurveTo(0.5, 1.2, 1.0, 0.0, 0.0, -1.0);
            context.closePath();
            context.fill();
            context.restore();

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // è¾…åŠ©ï¼šç”Ÿæˆç®€å•åœ†å½¢çº¹ç†
        function getCircleTexture() {
            const size = 64; 
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const context = canvas.getContext('2d');
            const center = size / 2;
            const radius = size * 0.45;

            context.beginPath();
            context.arc(center, center, radius, 0, Math.PI * 2, false);
            context.fillStyle = 'white';
            context.fill();

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // æ¨¡å¼A: éšæœºæ˜Ÿäº‘ (ç«‹æ–¹ä½“ç©ºé—´å†…éšæœº)
        function generateStarfieldData() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                positionsStarfield[i3] = (Math.random() - 0.5) * 60;
                positionsStarfield[i3 + 1] = (Math.random() - 0.5) * 60;
                positionsStarfield[i3 + 2] = (Math.random() - 0.5) * 60;
            }
        }

        // æ¨¡å¼B: åœŸæ˜Ÿ (çƒä½“ + ç¯)
        function generateSaturnData() {
            const sphereCount = Math.floor(CONFIG.particleCount * 0.4); 
            const ringCount = CONFIG.particleCount - sphereCount;       

            // æ˜Ÿçƒæœ¬ä½“
            for (let i = 0; i < sphereCount; i++) {
                const i3 = i * 3;
                const radius = 6;
                const phi = Math.acos(-1 + (2 * i) / sphereCount);
                const theta = Math.sqrt(sphereCount * Math.PI) * phi;
                
                positionsSaturn[i3] = radius * Math.cos(theta) * Math.sin(phi);
                positionsSaturn[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                positionsSaturn[i3 + 2] = radius * Math.cos(phi);
            }

            // æ˜Ÿç¯
            for (let i = 0; i < ringCount; i++) {
                const i3 = (sphereCount + i) * 3;
                const distance = 8 + Math.random() * 10;
                const angle = Math.random() * Math.PI * 2;
                const thickness = (Math.random() - 0.5) * 0.5;

                positionsSaturn[i3] = Math.cos(angle) * distance;
                positionsSaturn[i3 + 1] = thickness + Math.sin(angle) * (distance * 0.1); 
                positionsSaturn[i3 + 2] = Math.sin(angle) * distance;
            }
        }

        // æ¨¡å¼C: I LOVE YOU (ç¨‹åºåŒ–ç”Ÿæˆå—çŠ¶æ–‡å­—) - NEW
        function getLetterPoints(letter, offsetX, scale = 1.0) {
            // å®šä¹‰ç²’å­åœ¨å±€éƒ¨åæ ‡ç³»ä¸­çš„åˆ†å¸ƒç‚¹
            const points = [];
            const size = 5 * scale;
            const thickness = 1 * scale;
            const halfSize = size / 2;
            const halfThickness = thickness / 2;
            const particleDensity = 40; 

            // ç®€åŒ–åæ ‡å®šä¹‰ï¼š[X_Center, Y_Center, Z_Center, Width, Height, Depth]
            const letterMaps = {
                // I
                'I': [
                    [0, 0, 0, thickness, size, thickness], 
                ],
                // L
                'L': [
                    [-halfSize, 0, 0, thickness, size, thickness], 
                    [0, -halfSize, 0, size, thickness, thickness], 
                ],
                // O (Box outline approximation)
                'O': [
                    [0, halfSize, 0, size, thickness, thickness], 
                    [0, -halfSize, 0, size, thickness, thickness],
                    [halfSize, 0, 0, thickness, size, thickness],
                    [-halfSize, 0, 0, thickness, size, thickness],
                ],
                // V (using two diagonal bars, approximation for simple block)
                'V': [
                    [-halfSize * 0.7, halfSize * 0.5, 0, thickness, size, thickness], 
                    [halfSize * 0.7, halfSize * 0.5, 0, thickness, size, thickness], 
                ],
                // E
                'E': [
                    [-halfSize, 0, 0, thickness, size, thickness], 
                    [0, halfSize, 0, size, thickness, thickness], 
                    [0, 0, 0, size * 0.7, thickness, thickness], 
                    [0, -halfSize, 0, size, thickness, thickness], 
                ],
                // Y (using two arms and stem)
                'Y': [
                    [-halfSize * 0.7, halfSize * 0.5, 0, thickness, size * 0.6, thickness], 
                    [halfSize * 0.7, halfSize * 0.5, 0, thickness, size * 0.6, thickness], 
                    [0, -halfSize * 0.7, 0, thickness, size * 0.6, thickness],
                ],
                // U
                'U': [
                    [-halfSize, 0, 0, thickness, size, thickness], 
                    [halfSize, 0, 0, thickness, size, thickness], 
                    [0, -halfSize, 0, size, thickness, thickness], 
                ],
                // Space
                ' ': []
            };

            const map = letterMaps[letter];
            if (!map) return points;

            // ç²’å­å¡«å……é€»è¾‘
            map.forEach(([cx, cy, cz, w, h, d]) => {
                for (let i = 0; i < particleDensity; i++) {
                    const x = cx + (Math.random() - 0.5) * w;
                    const y = cy + (Math.random() - 0.5) * h;
                    const z = cz + (Math.random() - 0.5) * d;
                    
                    // åŠ ä¸Šæ–‡å­—å—çš„æ•´ä½“åç§»é‡
                    points.push(x + offsetX, y, z);
                }
            });

            return points;
        }

        function generateILoveYouData() {
            const text = "I LOVE YOU";
            const letters = text.split('');
            const scaleFactor = 0.8; // ç¼©å°æ–‡å­—å¤§å° (ä» 1.5 é™åˆ° 0.8)
            const letterSpacing = 4.5 * scaleFactor; // ç¼©å°å­—æ¯é—´è·
            const totalLetters = letters.filter(l => l !== ' ').length;
            const totalWidth = totalLetters * (letterSpacing * 1.5) ; // ç²—ç•¥è®¡ç®—æ€»å®½åº¦
            let currentX = -(totalWidth / 2); // ä»ä¸­å¿ƒå¼€å§‹ï¼Œå‘å·¦åç§»
            const allTextPoints = [];

            // 1. ç”Ÿæˆæ‰€æœ‰å­—æ¯çš„ç²’å­ç‚¹
            letters.forEach(letter => {
                // å¦‚æœæ˜¯ç©ºæ ¼ï¼Œåªå¢åŠ é—´è·
                if (letter === ' ') {
                    currentX += letterSpacing * 0.5;
                    return;
                }
                const letterPoints = getLetterPoints(letter, currentX, scaleFactor); 
                allTextPoints.push(...letterPoints);
                currentX += letterSpacing;
            });
            
            // 2. å°†ç”Ÿæˆçš„ç²’å­ç‚¹æ˜ å°„åˆ°æ€»ç²’å­æ•°ç»„
            const numGeneratedPoints = allTextPoints.length / 3;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                if (numGeneratedPoints > 0) {
                    const sourceIndex = (i % numGeneratedPoints) * 3;
                    positionsILoveYou[i3] = allTextPoints[sourceIndex];
                    positionsILoveYou[i3 + 1] = allTextPoints[sourceIndex + 1];
                    positionsILoveYou[i3 + 2] = allTextPoints[sourceIndex + 2];
                } else {
                    positionsILoveYou[i3] = (Math.random() - 0.5) * 5;
                    positionsILoveYou[i3 + 1] = (Math.random() - 0.5) * 5;
                    positionsILoveYou[i3 + 2] = (Math.random() - 0.5) * 5;
                }
            }
        }
        
        // åˆå§‹åŒ–èƒŒæ™¯æ˜Ÿç©º
        function initBackgroundStars() {
            const backgroundGeometry = new THREE.BufferGeometry();
            const backgroundPositions = new Float32Array(BACKGROUND_STAR_COUNT * 3);
            const backgroundSprite = getCircleTexture();

            for (let i = 0; i < BACKGROUND_STAR_COUNT; i++) {
                const i3 = i * 3;
                const distance = 100 + Math.random() * 50; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1); 

                backgroundPositions[i3] = distance * Math.sin(phi) * Math.cos(theta);
                backgroundPositions[i3 + 1] = distance * Math.sin(phi) * Math.sin(theta);
                backgroundPositions[i3 + 2] = distance * Math.cos(phi);
            }

            backgroundGeometry.setAttribute('position', new THREE.BufferAttribute(backgroundPositions, 3));

            const backgroundMaterial = new THREE.PointsMaterial({
                size: 0.1, 
                map: backgroundSprite,
                color: 0xffffff,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false, 
                opacity: 0.8 
            });

            backgroundStars = new THREE.Points(backgroundGeometry, backgroundMaterial);
            scene.add(backgroundStars);
        }


        // --- 3. æ‰‹åŠ¿ä¸åŠ¨ç”»é€»è¾‘ ---

        function animate() {
            animationId = requestAnimationFrame(animate);

            // 1. æ—‹è½¬åœºæ™¯
            if(particles) {
                // æ‰‹åŠ¿æ§åˆ¶çš„ Y è½´æ—‹è½¬
                rotationVelocity += (targetRotationY - particles.rotation.y) * 0.05; 
                rotationVelocity *= 0.85; 
                particles.rotation.y += rotationVelocity * 0.1; 

                // Z è½´å€¾è§’
                if(targetMode === 'saturn') {
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0.4, 0.05);
                } else {
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
                }
            }
            
            // æ—‹è½¬èƒŒæ™¯æ˜Ÿç©º
            if(backgroundStars) {
                backgroundStars.rotation.x += 0.0001;
                backgroundStars.rotation.y += 0.00005;
            }


            // 2. I LOVE YOU æ¨¡å¼è®¡æ—¶å’Œåˆ‡æ¢
            const countdownEl = document.getElementById('text-countdown');
            if (isMaxExpansion && !isILoveYouMode) {
                const elapsed = Date.now() - maxExpansionStartTime;
                const remaining = Math.max(0, CONFIG.textDelayDuration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.innerText = `èšåˆå€’è®¡æ—¶: ${seconds}s`;
                countdownEl.style.opacity = 1;

                if (elapsed >= CONFIG.textDelayDuration) {
                    // è§¦å‘ I LOVE YOU æ¨¡å¼
                    isILoveYouMode = true;
                    // ä¿å­˜å½“å‰çš„éæ–‡å­—æ¨¡å¼
                    originalMode = targetMode; 
                    targetMode = 'iloveyou';
                    handExpansionFactor = 0; // ç²’å­å¼€å§‹èšåˆ
                    isMaxExpansion = false;
                    maxExpansionStartTime = 0;
                    countdownEl.style.opacity = 0;
                }
            } else {
                countdownEl.style.opacity = 0;
            }

            // 3. æ›´æ–°æ‰©æ•£ç³»æ•° (åŸºäºæ‰‹åŠ¿)
            smoothedExpansion += (handExpansionFactor - smoothedExpansion) * 0.1;
            
            // æ›´æ–°UIæ•°å€¼
            const percent = Math.round(smoothedExpansion * 100);
            document.getElementById('diffusion-val').innerText = `${percent}%`;
            document.getElementById('gesture-feedback').style.opacity = percent > 5 ? 1 : 0;

            // 4. ç²’å­ä½ç½®æ›´æ–°çš„æ ¸å¿ƒé€»è¾‘
            updateParticles();

            renderer.render(scene, camera);
        }

        function updateParticles() {
            if (!particles) return;

            const positions = particles.geometry.attributes.position.array;
            let targetPositions;
            
            // æ ¹æ®å½“å‰æ¨¡å¼é€‰æ‹©ç›®æ ‡ä½ç½®æ•°ç»„
            if (targetMode === 'starfield') {
                targetPositions = positionsStarfield;
            } else if (targetMode === 'saturn') {
                targetPositions = positionsSaturn;
            } else if (targetMode === 'iloveyou') {
                targetPositions = positionsILoveYou;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;

                // A. è·å–ç›®æ ‡åŸºç¡€ä½ç½®
                const tx = targetPositions[i3];
                const ty = targetPositions[i3 + 1];
                const tz = targetPositions[i3 + 2];

                // B. è®¡ç®—æ‰©æ•£åçš„ä½ç½® (Explosion effect) - ä»…åœ¨éæ–‡å­—æ¨¡å¼ä¸‹åº”ç”¨
                let finalTx = tx;
                let finalTy = ty;
                let finalTz = tz;
                
                if (!isILoveYouMode) {
                    // æ™®é€šæ¨¡å¼ä¸‹çš„æ‰©å¼ å’Œéšæœºå™ªç‚¹
                    const noiseX = (Math.random() - 0.5) * 5 * smoothedExpansion;
                    const noiseY = (Math.random() - 0.5) * 5 * smoothedExpansion;
                    const noiseZ = (Math.random() - 0.5) * 5 * smoothedExpansion;

                    const expansionMult = 1 + (smoothedExpansion * 3); // æœ€å¤§æ”¾å¤§4å€

                    finalTx = tx * expansionMult + noiseX;
                    finalTy = ty * expansionMult + noiseY;
                    finalTz = tz * expansionMult + noiseZ;
                }


                // C. ç§»åŠ¨å½“å‰ç²’å­å‘ç›®æ ‡ä½ç½® (Lerp)
                positions[i3]     += (finalTx - positions[i3]) * CONFIG.lerpSpeed;
                positions[i3 + 1] += (finalTy - positions[i3 + 1]) * CONFIG.lerpSpeed;
                positions[i3 + 2] += (finalTz - positions[i3 + 2]) * CONFIG.lerpSpeed;
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }


        // --- 4. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        
        const videoElement = document.querySelector('.input_video');
        
        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‹‡æŒ‡å°–å’Œé£ŸæŒ‡å°–çš„è·ç¦»ï¼Œè¿”å›æ‰©å¼ å› å­
        function getExpansionFactor(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];

            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) +
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            const minD = 0.05; // æåˆæœ€å°å€¼
            const maxD = 0.4; // å¼ å¼€æœ€å¤§å€¼
            
            let factor = (distance - minD) / (maxD - minD);
            return Math.max(0, Math.min(1, factor));
        }

        function onResults(results) {
            // éšè—åŠ è½½å±‚
            const loader = document.getElementById('loading');
            if(loader && loader.style.display !== 'none') {
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 500);
                // äº®èµ·çŠ¶æ€ç¯
                document.getElementById('hand-status').classList.remove('bg-red-500');
                document.getElementById('hand-status').classList.add('bg-green-500');
                document.getElementById('hand-status').style.boxShadow = "0 0 10px rgba(34,197,94,0.8)";
            }

            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            
            // --- æ—‹è½¬æ§åˆ¶é€»è¾‘ (åªåŸºäºç¬¬ä¸€åªæ‰‹) ---
            if (handCount > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wristX = landmarks[0].x; 

                if (lastHandX !== null && !isILoveYouMode) { // æ–‡å­—æ¨¡å¼ä¸‹ä¸æ—‹è½¬ï¼Œé˜²æ­¢æ¨¡å‹åœ¨èšåˆæ—¶æŠ–åŠ¨
                    const deltaX = wristX - lastHandX;
                    targetRotationY -= deltaX * 5.0; 
                }
                lastHandX = wristX;

                // åªæœ‰ç¬¬ä¸€åªæ‰‹çš„æ‰©å¼ å› å­ç”¨äºæ™®é€šæ¨¡å¼ä¸‹çš„æ‰©æ•£æ§åˆ¶
                const factor = getExpansionFactor(landmarks);
                handExpansionFactor = factor;

                // --- I LOVE YOU çŠ¶æ€æœºæ£€æµ‹ ---
                if (!isILoveYouMode) {
                    if (factor >= CONFIG.maxExpansionThreshold) {
                        if (!isMaxExpansion) {
                            // é¦–æ¬¡è¾¾åˆ°æœ€å¤§æ‰©å¼ ï¼Œå¼€å§‹è®¡æ—¶
                            isMaxExpansion = true;
                            maxExpansionStartTime = Date.now();
                        }
                    } else {
                        // æ‰©å¼ ä¸­æ–­
                        isMaxExpansion = false;
                        maxExpansionStartTime = 0;
                    }
                }
            } else {
                // å¦‚æœæ‰‹ç¦»å¼€äº†ï¼Œé‡ç½®æ‰‹éƒ¨Xè¿½è¸ªï¼Œå¹¶æ…¢æ…¢è¡°å‡ç²’å­æ‰©å¼ 
                lastHandX = null; 
                handExpansionFactor = handExpansionFactor * 0.95;
                isMaxExpansion = false;
                maxExpansionStartTime = 0;
            }

            // --- åŒæ‰‹é€€å‡ºæ–‡å­—æ¨¡å¼é€»è¾‘ (NEW) ---
            if (isILoveYouMode && handCount >= 2) {
                // è®¡ç®—ä¸¤åªæ‰‹çš„æ‰©å¼ å› å­
                const factor1 = getExpansionFactor(results.multiHandLandmarks[0]);
                const factor2 = getExpansionFactor(results.multiHandLandmarks[1]);

                // å¦‚æœä¸¤åªæ‰‹éƒ½å¤„äºæåˆçŠ¶æ€ (æ‰©å¼ å› å­ä½äºé˜ˆå€¼)
                if (factor1 <= CONFIG.exitTextThreshold && factor2 <= CONFIG.exitTextThreshold) {
                    isILoveYouMode = false;
                    // è¿”å›åˆ°è¿›å…¥æ–‡å­—æ¨¡å¼å‰çš„æ¨¡å¼ (å¯èƒ½æ˜¯ starfield æˆ– saturn)
                    targetMode = originalMode; 
                    switchMode(targetMode); // æ›´æ–° UI
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, // å…è®¸åŒæ‰‹è¿½è¸ª
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // å¯åŠ¨æ‘„åƒå¤´
        cameraUtils.start().catch(err => {
            console.error("Camera error:", err);
            console.error("æ— æ³•å¯åŠ¨æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿å…è®¸æƒé™ã€‚"); 
            document.querySelector('#loading div:nth-child(2)').innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥";
        });


        // --- 5. UI äº¤äº’é€»è¾‘ ---

        // æ¨¡å¼åˆ‡æ¢
        window.switchMode = (mode) => {
            // åœ¨è¿™é‡Œä»…æ›´æ–° UI æŒ‰é’®çŠ¶æ€ï¼Œå®é™…çš„ targetMode å¯èƒ½ä¼šè¢«æ‰‹åŠ¿é€»è¾‘è¦†ç›–
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('bg-red-500/40', 'bg-purple-500/40', 'border-red-400', 'border-purple-400', 'text-white');
                btn.classList.add('bg-white/10', 'border-white/5');
            });
            
            if (mode !== 'iloveyou') {
                targetMode = mode; // åªæœ‰éæ–‡å­—æ¨¡å¼æ‰å…è®¸é€šè¿‡æŒ‰é’®åˆ‡æ¢
                
                const activeBtn = document.getElementById(`btn-${mode}`);
                activeBtn.classList.remove('bg-white/10', 'border-white/5');
                
                if(mode === 'starfield') {
                    activeBtn.classList.add('bg-red-500/40', 'border-red-400', 'text-white');
                } else {
                    activeBtn.classList.add('bg-purple-500/40', 'border-purple-400', 'text-white');
                }
            }
        };

        // é¢œè‰²é€‰æ‹©å™¨
        const colorPicker = document.getElementById('colorPicker');
        const colorValue = document.getElementById('colorValue');

        colorPicker.addEventListener('input', (e) => {
            const hex = e.target.value;
            colorValue.innerText = hex.toUpperCase();
            
            if(particles) {
                material.color.set(hex);
            }
        });

        // çª—å£è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å…¨å±åˆ‡æ¢ - å¢å¼ºç‰ˆé€»è¾‘
        window.toggleFullScreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        // ç›‘å¬å…¨å±å˜åŒ–æ›´æ–°å›¾æ ‡
        document.addEventListener('fullscreenchange', () => {
            const isFullScreen = !!document.fullscreenElement;
            const btn = document.getElementById('fullscreen-btn');
            const iconEnter = document.getElementById('icon-enter');
            const iconExit = document.getElementById('icon-exit');
            
            if (isFullScreen) {
                iconEnter.classList.add('hidden');
                iconExit.classList.remove('hidden');
                btn.classList.add('bg-red-500/20'); 
                btn.title = "é€€å‡ºå…¨å±";
            } else {
                iconEnter.classList.remove('hidden');
                iconExit.classList.add('hidden');
                btn.classList.remove('bg-red-500/20');
                btn.title = "åˆ‡æ¢å…¨å±";
            }
        });

        // åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
        switchMode('saturn'); // é»˜è®¤é€‰ä¸­ 'saturn' æ¨¡å¼
        initThree();

    </script>
</body>
</html>
